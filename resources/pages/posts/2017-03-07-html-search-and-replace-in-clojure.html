{:title "HTML search and replace in Clojure"
 :author-id :jkpl
 :description "Clojure's core data structures and rich standard library make it attractive for solving data munching problems from other domains. In this blog post, I'll show how to do HTML transformations using Clojure."
 :tags  ["clojure"]}

---

<p>In Clojure, data structures are mostly built from a handful of <a href="https://clojure.org/reference/data_structures">core data structures</a> such as lists, vectors, maps, and sets. This means that most data structures can leverage all of the generic data transformation and querying functions built for the core data structures instead of having to rebuild the same functionality for each data structure. This feature in combination with Clojure's rich standard library makes Clojure very attractive for solving data munching problems from other domains.</p>
<p>In this article, I'm going to demonstrate these capabilities for solving HTML transformations using Clojure. First, I'm going to describe how HTML can be represented in Clojure. With this representation in mind, I'll demonstrate how we can transform HTML documents in Clojure. Finally, I'll tie the transformations together with the HTML parsing and formatting to produce a complete solution.</p>
<p>This blog post was first published in <a href="http://www.cakesolutions.net/teamblogs/html-search-and-replace-in-clojure">Cake Solutions's tech blog</a>.</p>
<h2 id="clojure-representation-for-html">Clojure representation for HTML</h2>
<p>HTML is a fairly consistent format. HTML documents are mostly composed from elements that have the following properties:</p>
<ul>
<li>They have a name.</li>
<li>They have zero or more attributes.</li>
<li>They can contain zero or more tag or text elements.</li>
</ul>
<p>Besides tags and text elements, HTML documents can also contain a DTD (Document Type Declaration) and comments. For the sake of simplicity, we can ignore the DTD and interpret comments as text elements.</p>
<p>With these properties in mind, we can represent HTML tags in many styles using Clojure's core data structures. <a href="https://github.com/weavejester/hiccup">Hiccup</a>, a Clojure library for converting Clojure data structures to HTML, represents HTML tags as Clojure vectors with the following properties:</p>
<ol style="list-style-type: decimal">
<li>The tag name is represented as a keyword in the head of the vector.</li>
<li>The tag attributes are represented as a map in the second value of the vector.</li>
<li>The rest of the vector elements represent the body of the HTML tag.</li>
</ol>
<p>For example, a list in HTML...</p>
<pre class="html"><code>&lt;ul class=&quot;navbar&quot;&gt;
  &lt;li&gt;Hello world!&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;about.html&quot;&gt;About&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>...can be represented in Hiccup format (with the whitespace omitted) as follows:</p>
<pre class="clojure"><code>[:ul {:class &quot;navbar&quot;}
 [:li {} &quot;Hello world!&quot;]
 [:li {}
  [:a {:href &quot;about.html&quot;} &quot;About&quot;]]]</code></pre>
<h2 id="mission-adding-a-root-path-to-absolute-paths">Mission: adding a root path to absolute paths</h2>
<p>Now that we have a language for describing HTML in Clojure data structures, we can build HTML transformations in Clojure.</p>
<p>One example of such transformations is adding a root path to each absolute path appearing in URI attributes. For example, links such as <code>&lt;a href=&quot;/index.html&quot;&gt;...&lt;/a&gt;</code> would be transformed to <code>&lt;a href=&quot;/root/index.html&quot;&gt;...&lt;/a&gt;</code>. This transformation is common for moving complete websites under a new directory structure.</p>
<p>First, we'll need to specify what an absolute path is. All absolute paths start with a single <code>/</code> character. Note that paths with two <code>/</code> characters refer to <a href="https://www.paulirish.com/2010/the-protocol-relative-url/">protocol-relative URL</a>.</p>
<pre class="clojure"><code>(defn absolute-path?
  [^String uri]
  (and (.startsWith uri &quot;/&quot;)
       (not (.startsWith uri &quot;//&quot;))))</code></pre>
<p>With this in mind, we can write a function that skips all the URIs that are not absolute paths, and transform the ones that are. Adding a root path itself is as easy as string concatenation:</p>
<pre class="clojure"><code>(defn add-root-to-uri
  [root-path uri]
  (if (and (not (empty? root-path))
           (absolute-path? uri))
    (str (string/replace root-path #&quot;^/*&quot; &quot;/&quot;) uri)
    uri))</code></pre>
<p>Next, we'll need to specify the attributes that can contain absolute paths. There are many <a href="https://www.w3.org/TR/REC-html40/index/attributes.html">attributes that accept an URI</a>, but for the simplicity of this exercise, we'll just focus on the two obvious ones: <code>href</code> in <code>a</code> tags, and <code>src</code> in <code>img</code> tags. Let's define a set for the attribute keys.</p>
<pre class="clojure"><code>(def attr-names-with-uris #{:src :href})</code></pre>
<p>Now we can apply the transformation to all HTML attributes (key-value pairs). If the attribute key is defined in the set above, we apply the URI transformation to the attribute value. Otherwise, we'll keep the attribute value the same.</p>
<pre class="clojure"><code>(defn add-root-to-uri-attr
  [root-path [key value]]
  [key (if (attr-names-with-uris key)
         (add-root-to-uri root-path value)
         value)])</code></pre>
<h2 id="transforming-the-html-with-recursion">Transforming the HTML with recursion</h2>
<p>HTML documents can be thought of as trees where HTML elements are either nodes or leaves in the tree. Therefore, in order to apply a transformation, we can use common tree traversing strategies for making the modification across the whole tree. What's an easy way to traverse a tree? Recursively, of course!</p>
<pre class="clojure"><code>(defn add-root-to-html-recur
  [root-path html]
  (if (vector? html)                   ; Is it an HTML tag?
    (let [[tag attrs &amp; body] html      ; Unpack the tag
          attrs (-&gt;&gt; attrs             ; Update the attributes
                     (map (partial add-root-to-uri-attr root-path))
                     (into {}))
          body (-&gt;&gt; body               ; Update the body (recursion)
                    (map (partial add-root-to-html-recur root-path)))]
      (vec (concat [tag attrs] body))) ; Rebuild the tag with the updates intact
    html))</code></pre>
<p>In the code listing above, we've defined a function for updating the root path to all URI attributes recursively. The function unpacks the given the HTML tag (a vector), updates its attributes with the previously defined attribute transformer, applies the same function the child nodes, and finally rebuilds the node with the updates from the two previous steps. If the given HTML node is not a tag (i.e. it's text instead), no transformation is necessary. This, in combination with the empty node body, acts as the termination mechanism for the recursion.</p>
<h2 id="getting-rid-of-the-recursion">Getting rid of the recursion</h2>
<p>Recursive traversal is fairly easy to understand, but it has many of the usual problems of recursive functions:</p>
<ol style="list-style-type: decimal">
<li>The function must be called explicitly in order to ensure the whole tree is processed.</li>
<li>The function must have proper recursion termination conditions in place in order to prevent infinite recursion.</li>
<li>Although HTML documents are often shallow, and thus the use of call stack for tracking the traversal progress is rarely a problem, it is something to consider in case of an odd deep document.</li>
</ol>
<p>Since it's just a Clojure core data structure we're traversing, surely there's a generic way to traverse the tree? And indeed there is a module for that in the Clojure standard library: <a href="https://clojuredocs.org/clojure.walk">clojure.walk</a>. The walk module provides functions for traversing arbitrary Clojure data structures. The functions in the module take a data structure, they call a given function to each substructure, and build a new data structure with the earlier substructure replaced with the result of the given function.</p>
<p>One of the traversal functions in the module is <a href="https://clojuredocs.org/clojure.walk/postwalk">postwalk</a>, which performs a depth-first, post-order traversal on the given data structure. We can use <code>println</code> to give us an idea on how it works.</p>
<pre class="clojure"><code>(require &#39;clojure.walk)

(clojure.walk/postwalk
 (fn [x] (println x) x)
 [:p {}
  [:a {:href &quot;about.html&quot; :title &quot;About&quot;} &quot;See about&quot;]])

;; Output
:p
{}
:a
:href
about.html
[:href about.html]
:title
About
[:title About]
{:href about.html, :title About}
See about
[:a {:href about.html, :title About} See about]
[:p {} [:a {:href about.html, :title About} See about]]</code></pre>
<p>As we can see from the output, <code>postwalk</code> hits the <code>href</code> key-value among other items in the tree. Since we're now using a more generic traversal method, the transformation passed to <code>postwalk</code> is applied to all substructures rather than just the attributes map. Therefore, we need to use a filter to select which structures to apply our transformation on. We can easily achieve this using a predicate that checks if the structure is an attribute, i.e. a key-value pair. Each key-value pair is a vector of two elements, and in this case the first element (the key) is always a keyword.</p>
<pre class="clojure"><code>(defn key-value?
  [x]
  (and (vector? x)
       (= (count x) 2)
       (keyword? (first x))))</code></pre>
<p>We can reuse the URI attribute transformer we implemented earlier, and combine it with <code>postwalk</code> and the predicate from above. As before, we apply the transformation for all key-value pairs, and simply keep the other structures as they are.</p>
<pre class="clojure"><code>(defn add-root-to-html
  [root-path html]
  (let [edit (fn [x]
               (if (key-value? x) ; only transform attributes
                 (add-root-to-uri-attr root-path x)
                 x))]
    (clojure.walk/postwalk edit html)))</code></pre>
<h2 id="tying-the-pieces-together">Tying the pieces together</h2>
<p>Now that we have a way to perform URI attribute transformation for an HTML document, let's wrap up the work by handling the conversion between HTML text and the Hiccup format.</p>
<p>We can parse the HTML text into Hiccup using the <a href="https://github.com/davidsantiago/hickory">Hickory</a> library. The parser will yield a sequence of Hiccup fragments it find from the given text.</p>
<pre class="clojure"><code>(require &#39;hickory.core)

(defn text-&gt;hiccup
  [text]
  (-&gt; text
      hickory.core/parse         ; parse HTML text
      hickory.core/as-hiccup))   ; convert it to Hiccup</code></pre>
<p>Once we've done our transformations, we can use the <a href="https://github.com/weavejester/hiccup">Hiccup</a> library to convert the data structures back to text. Note that Hiccup's <code>html</code> is a macro rather than a method, so we'll need to wrap it with a function in order to use it in function composition.</p>
<pre class="clojure"><code>(require &#39;hiccup.core)

(defn hiccup-&gt;text
  [html]
  (hiccup.core/html html))</code></pre>
<p>Finally, we'll combine these functions with the functions created earlier:</p>
<pre class="clojure"><code>(defn add-root-to-html-text
  [root-path html-str]
  (-&gt;&gt; html-str                 ; start with HTML string
       text-&gt;hiccup             ; convert it to Hiccup
       (map (comp hiccup-&gt;text  ; process each fragment
                  (partial add-root-to-html root-path)))
       clojure.string/join))    ; join the fragments to a single string</code></pre>
<p>And there we have it, a function that adds a root path to URIs in HTML text:</p>
<ol style="list-style-type: decimal">
<li>The given HTML text is parsed into a sequence of Hiccup fragments.</li>
<li>Root path is added to all the URI attributes in each Hiccup fragment.</li>
<li>Each processed Hiccup fragment is converted back to HTML text.</li>
<li>All the HTML text fragments are joined back into a single string.</li>
</ol>
<p>We can, of course, further combine this with <a href="https://clojuredocs.org/clojure.core/slurp">file reading</a> and <a href="https://clojuredocs.org/clojure.core/spit">writing</a> or an HTTP server library like <a href="https://github.com/ring-clojure/ring">Ring</a> or <a href="http://www.http-kit.org/">HTTP Kit</a>.</p>
<h2 id="conclusions">Conclusions</h2>
<p>In this article, I've demonstrated how we can represent languages such as HTML in Clojure data structures, and how we can solve HTML transformation problems using Clojure as our tool. We've also seen some examples on how Clojure provides nice, out-of-the-box tooling such as traversal for its core data structures.</p>
<p>As always, I've included the code examples in a <a href="https://gist.github.com/jkpl/e316ef7e975f1ff13205e3877f02d2d7">GitHub Gist</a> to play around with. Thanks for reading!</p>
