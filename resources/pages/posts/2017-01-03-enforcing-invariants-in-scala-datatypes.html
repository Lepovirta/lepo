{:title "Enforcing invariants in Scala datatypes"
 :author-id :jkpl
 :description "Scala provides many tools for building programs with less runtime errors. In this blog post, I'll show how to enforce invariants in datatypes in a type-safe way."
 :tags  ["scala"]}

---

<p>Scala provides many tools to help us build programs with less runtime errors. Instead of relying on nulls, the recommended practice is to use the <code>Option</code> type. Instead of throwing exceptions, <code>Try</code> and <code>Either</code> types are used for representing potential error scenarios. What's common with these features is that they're used for capturing runtime features in the type system, thus lifting the runtime scenario handling to the compilation phase: your program doesn't compile until you've explicitly handled nulls, exceptions, and other runtime features in your code.</p>
<p>In his &quot;Strategic Scala Style&quot; blog post series, Li Haoyi explores <a href="http://www.lihaoyi.com/post/StrategicScalaStyleDesigningDatatypes.html">patterns for enforcing invariants in datatypes</a> using techniques such as self-checks and structural enforcement. Some of the techniques described in the blog post rely on runtime assertions. Thus, while they prevent invalid data from appearing in your datatypes, the datatype construction is not fully represented in the type system.</p>
<p>In this blog post, I'll expand the techniques by demonstrating ways to enforce invariants using type-safe, compile-time techniques. First, I'll demonstrate how the runtime assertion style works using an example datatype. I'll then show how we can enforce invariants in the example datatype in a type-safe style. Finally, I'll briefly cover the pitfalls of using case classes for datatypes with type-safe invariant validation, and how we can regain the case class features using tricks in the class inheritance system and ScalaMeta macros. This blog post was first published in <a href="http://www.cakesolutions.net/teamblogs/enforcing-invariants-in-scala-datatypes">Cake Solutions's tech blog</a>.</p>
<h2 id="invariant-validation-using-runtime-assertions">Invariant validation using runtime assertions</h2>
<p>As an example, let's create a datatype for conferences. A conference has a name, a start date, and an end date. The name of the conference cannot be empty, and the end date cannot be before the start date. Using the runtime assertion technique, the datatype could be represented as follows:</p>
<pre class="scala"><code>import java.time.LocalDate

case class Conference(name: String, startDate: LocalDate, endDate: LocalDate) {
  require(name.nonEmpty)
  require(startDate.isEqual(endDate) || startDate.isBefore(endDate))
}
</code></pre>
<p>In the example above, we use Scala's builtin function <code>require</code> to ensure our datatype complies to our requirements. In order to ensure we've captured the potential runtime errors, we can either wrap the datatype construction with a try-catch block or the <code>Try</code> constructor:</p>
<pre class="scala"><code>try {
  val invalidConference = new Conference(&quot;&quot;, LocalDate.now(), LocalDate.now())
} catch {
  case ex: IllegalArgumentException =&gt;
    // Handle the error in any way you like here
    println(&quot;Invalid parameters when creating a conference: &quot; + ex.getMessage)
}

val invalidConference: Try[Conference] = Try(new Conference(&quot;&quot;, LocalDate.now(), LocalDate.now()))
</code></pre>
<p>The issue here is the same as with any other function that throws errors: the function is partial, not total. This means that only a subset of inputs will produce a value corresponding to the expected type while the rest of the inputs will cause the program execution to escape the normal program flow. The outcome of the invalid inputs is not represented in the type system, thus it is not type-safe.</p>
<p>In practice, the issue with invariant validation that is not type-safe is that it puts the burden of capturing errors on the user's side. Failing to capture errors produces non-working software in places where you'd normally expect them work just fine. As the places where the datatype is constructed increases, so does the chance of failing to capture the errors.</p>
<h2 id="enforcing-invariants-in-a-type-safe-style">Enforcing invariants in a type-safe style</h2>
<p>In order ease the burden of manually catching errors, we can make the invariant validation type-safe by representing the potential runtime errors in the type system. This can be done by providing the users a constructor that returns either the constructed value (an instance of a conference) or an error value.</p>
<pre class="scala"><code>class Conference private (
  name: String,
  startDate: LocalDate,
  endDate: LocalDate
)

object Conference {
  def apply(name: String, startDate: LocalDate, endDate: LocalDate): Option[Conference] =
    if (name.nonEmpty &amp;&amp; (startDate.isEqual(endDate) || startDate.isBefore(endDate))) {
      Some(new Conference(name, startDate, endDate))
    } else {
      None
    }
}

val validConference: Option[Conference] = Conference(&quot;ScalaDays 2017&quot;, LocalDate.of(2017, 5, 30), LocalDate.of(2017, 6, 2))
val invalidConference: Option[Conference] = Conference(&quot;&quot;, LocalDate.now(), LocaDate.now())
</code></pre>
<p>In the example above, we've defined a class for the conference datatype, and an alternative constructor function in the datatype's companion object that validates the input. For the sake of simplicity, we've represented the return type of the alternative constructor as an <code>Option[Conference]</code>, where the absence of the value represents a validation error.</p>
<p>We've also hidden the primary constructor of the datatype. This way the constructor can only be used in the scope of the alternative constructor to create validated instances. If the constructor is not hidden, invalid instances may be created by the user accidentally using the wrong constructor. Hiding the primary constructor also effectively prevents the extension of the class.</p>
<p>A more detailed representation of the construction could include more details about the invariant validation errors. When using the <code>Either</code> type, one of the sides in the type could be used for representing one or more validation errors, while the other side would represent the successful value. For example in <code>Either[List[Error], Conference]</code>, the left-side represents all of the errors found during construction, and the right-side represents the successfully built instance of a conference. Regardless of which return type is used, the pattern for building type-safe values is similar: the return value must be &quot;unwrapped&quot; to reach the actual value.</p>
<p>We can further enhance the validation process by creating meaningful datatypes for the datatype's fields. For example, the name of the conference can made to its own datatype with its own validation rules:</p>
<pre class="scala"><code>class Name private (val name: String) extends AnyVal

object Name {
  def apply(name: String): Option[Name] =
    if (name.nonEmpty) Some(new Name(name))
    else None
}
</code></pre>
<p>Here the name is encapsulated in a single value class. By making the datatype a value class (i.e. it extends <code>AnyVal</code>), we can in some cases avoid the overhead of allocating the object around the string, but at the same time enjoy the type-safety it provides compared to plain strings. As a value class, the class will also automatically have <code>equals</code> and <code>hashCode</code> methods based on the type it wraps.</p>
<p>With the <code>Name</code> type in place, we can make the <code>Conference</code> type use it without having to repeat the validation process.</p>
<pre class="scala"><code>class Conference private (
  name: Name,
  startDate: LocalDate,
  endDate: LocalDate
)

object Conference {
  def apply(name: Name, startDate: LocalDate, endDate: LocalDate): Option[Conference] =
    if (startDate.isEqual(endDate) || startDate.isBefore(endDate)) {
      Some(new Conference(name, startDate, endDate))
    } else {
      None
    }
}

val validConference: Option[Conference] = for {
  name &lt;- Name(&quot;ScalaDays 2017&quot;)
  conference &lt;- Conference(name, LocalDate.of(2017, 5, 30), LocalDate.of(2017, 6, 2))
} yield conference
</code></pre>
<h2 id="escaping-invariant-validation-in-case-class-datatypes">Escaping invariant validation in case class datatypes</h2>
<p>In Scala, case classes bring a bag full of goodies to regular old classes. For example, case classes have an automatically implemented <code>equals</code>, <code>hashCode</code>, <code>toString</code> methods, and an extractor for pattern matching based on the class fields.</p>
<p>Case classes are convenient for implementing datatypes, so it makes sense to use them as the base type for datatypes where invariants are validated in a type-safe way. However, they also make it easy to bypass the validation checks. Unlike regular classes, case classes have more than one constructor that need hiding. Besides the regular constructor, case classes can also be constructed using their auto-generated <code>apply</code> function and <code>copy</code> methods.</p>
<pre class="scala"><code>case class Conference private (
  name: String,
  startDate: LocalDate,
  endDate: LocalDate
)

object Conference {
  def create(name: String, startDate: LocalDate, endDate: LocalDate): Option[Conference] =
    if (name.nonEmpty &amp;&amp; (startDate.isEqual(endDate) || startDate.isBefore(endDate))) {
      Some(new Conference(name, startDate, endDate))
    } else {
      None
    }
}

// Invalid instance through apply function
val invalidConference1: Conference = Conference(&quot;&quot;, LocalDate.now(), LocalDate.now())

// Valid instance...
val Some(validConference) = Conference.create(&quot;ScalaDays 2017&quot;, LocalDate.of(2017, 5, 30), LocalDate.of(2017, 6, 2))

// ...can be a gateway to an invalid instance.
val invalidConference2: Conference = validConference.copy(name = &quot;&quot;)
</code></pre>
<p>In the example above, we've replaced the normal <code>Conference</code> class with a case class. We can still create validated instances of the datatype using the <code>create</code> function in the companion object. However, we can still access the auto-generated <code>apply</code> method, and create invalid instances that way. Moreover, we can use the <code>copy</code> method to create an invalid copy of the datatype from a valid datatype.</p>
<p>The <code>copy</code> method can be erased by manually overriding it with a method that doesn't produce invalid copies, but the <code>apply</code> function can neither be overridden or hidden. The inability to replace the function is why the validating constructor function has to occupy a different name. These features make case classes unfeasible for datatypes that enforce invariants in a type-safe way.</p>
<h2 id="regaining-the-case-class-features">Regaining the case class features</h2>
<p>As mentioned earlier, case classes contain a lot of useful features. Thus it would be a shame to lose them just because their <code>apply</code> and <code>copy</code> constructors clash with the invariant validation process. How can we keep the case class features that don't conflict with the validation?</p>
<p>One way to have case classes without <code>apply</code> and <code>copy</code> constructors is to make the case classes <a href="https://gist.github.com/tpolecat/a5cb0dc9adeacc93f846835ed21c92d2">abstract and sealed</a>. Like any other class, case classes can be made abstract. This means that the class may define function interfaces that are left open for implementation in its subclasses. It also means that the class must be extended as no instance of it can be created directly even when there's nothing left for the subclass to implement. Therefore, <code>apply</code> or <code>copy</code> constructors are not generated for the case class because there's no known constructor to base their implementation on.</p>
<p>Because there is no <code>final</code> modifier for limiting subclassing with traits and <code>abstract</code> classes, we'll have to use the <code>sealed</code> modifier instead. The <code>sealed</code> modifier allows us to limit the scope in which subclasses are made to the source file. Thus, no instances can be made without accessing the constructors we provide.</p>
<pre class="scala"><code>sealed abstract case class Conference(name: String, startDate: LocalDate, endDate: LocalDate)

object Conference {
  def apply(name: Name, startDate: LocalDate, endDate: LocalDate): Option[Conference] =
    if (name.nonEmpty &amp;&amp; (startDate.isEqual(endDate) || startDate.isBefore(endDate)))
      Some(new Conference(name, startDate, endDate) {})
    else
      None
}
</code></pre>
<p>In the example above, we've recreated the earlier <code>Conference</code> datatype, but this time as a sealed abstract case class. Our only means of constructing an instance is through the custom constructor we provide. However, as the datatype is now a case class, we can use its case class features such as auto-generated <code>equals</code> and <code>hashCode</code> functions.</p>
<p>An alternative way to get case class features in a regular class is to use <a href="http://scalameta.org/">ScalaMeta</a>'s <code>@data</code> annotation macro. The <code>@data</code> annotation macro automatically generates case class features for any regular class that uses the annotation. The annotation allows selecting which case class features are included for each class.</p>
<p>In order to use the annotation, we first need to enable ScalaMeta and the <a href="https://github.com/scalameta/paradise">paradise compiler plugin</a> for the project. Here's an example of what needs to be added to our SBT configuration:</p>
<pre class="scala"><code>// Resolvers for the ScalaMeta library and paradise plugin
resolvers in ThisBuild += Resolver.url(&quot;scalameta&quot;, url(&quot;http://dl.bintray.com/scalameta/maven&quot;))(Resolver.ivyStylePatterns)

// Enable paradise compiler plugin
addCompilerPlugin(&quot;org.scalameta&quot; % &quot;paradise&quot; % &quot;3.0.0.138&quot; cross CrossVersion.full)
scalacOptions += &quot;-Xplugin-require:macroparadise&quot;

// Add library dependency for ScalaMeta
libraryDependencies += &quot;org.scalameta&quot; %% &quot;scalameta&quot; % &quot;1.3.0&quot;
</code></pre>
<p>After enabling the library and the compiler plugin, we can use the <code>@data</code> annotation.</p>
<pre class="scala"><code>@data(copy = false, apply = false)
class Conference private (name: String, startDate: LocalDate, endDate: LocalDate)

object Conference {
  def apply(name: String, startDate: LocalDate, endDate: LocalDate): Option[Conference] =
    if (name.nonEmpty &amp;&amp; (startDate.isEqual(endDate) || startDate.isBefore(endDate)))
      Some(new Conference(name, startDate, endDate))
    else
      None
}
</code></pre>
<p>In the example above, we've annotated the <code>Conference</code> class with the <code>@data</code> annotation. By default, all of the case class features are enabled for the class. Here we've disabling the <code>copy</code> and <code>apply</code> constructors, thus we can have full control of the constructors that are visible to the datatype user.</p>
<h2 id="conclusions">Conclusions</h2>
<p>In this article, I've demonstrated a type-safe way for enforcing invariants in Scala datatypes. I've shown common techniques for invariant validation that are not type-safe and the issues commonly encountered with them. I've also shown the pitfalls of using case classes in combination with the type-safe invariant validation, and how those problems can be avoided using class inheritance and ScalaMeta macros.</p>
<p>As usual, I've made examples for the different invariant validation techniques available in a <a href="https://gist.github.com/jkpl/4932e8730c1810261381851b13dfd29d">Github Gist</a> to play around with. Thanks for reading!</p>
