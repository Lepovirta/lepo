{:title "Reusable response collectors in Akka"
 :author-id :jkpl
 :tags ["scala" "akka"]}

---

<p>One of the recommended practices in Akka is to use the <a href="http://techblog.net-a-porter.com/2013/12/ask-tell-and-per-request-actors/">response collector pattern</a> instead of the <a href="http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Ask__Send-And-Receive-Future">ask pattern</a> for request-response style actor communication. It simplifies actor communication by placing most of the response management under one specialised actor. Instead of adding timeout and error handling logic to several places in the actor system, the actors simply respond to any queries using the standard tell mechanism while the response collector actor decides when it has received enough responses.</p>

<p>It's easy to create an ad hoc response collector, but in many cases it would be nice to be able to reuse existing actor code.</p>

<p>In this article, I'll present a reusable response collector actor. First, I'll go over some of the common patterns that can be seen in many response collectors, and form an API for those patterns. After that, I'll present an implementation for the response collector actor that's using the API. Finally, I'll demonstrate a few examples of using the actor.</p>

<p>This article was first published in <a href="http://www.cakesolutions.net/teamblogs/reusable-response-collectors-in-akka-0">Cake Solutions's tech blog</a>.</p>

<h2>Common patterns in response collectors</h2>

<p>Response collector behaviour can be summarised as follows: collect relevant responses until all the results have been collected or a timeout has been exceeded, and make the results available to a consumer. There's quite a few requirements in that sentence. Let's see if we can extract individual patterns from it.</p>

<h3>Collecting relevant responses</h3>

<p>One caveat of Akka actors is that Akka doesn't enforce type safety in the processing of incoming messages. Specifically, each message handler has to be able to handle any type of incoming message. There are a few attempts at bringing type safety to Akka actors (see <a href="http://doc.akka.io/docs/akka/2.4.1/scala/typed-actors.html">Typed Actors</a> and <a href="http://doc.akka.io/docs/akka/2.4.1/scala/typed.html#typed-scala">Akka Typed</a>), but for the purpose of this exercise we'll just collect the interesting messages, and log an error for all the unexpected messages.</p>

<p>Scala's <code>PartialFunction</code> is useful for matching against a partial set of inputs. User can create a matcher of type <code>PartialFunction[Any, T]</code> where the type parameter <code>T</code> is the type of the expected output. For example, the following matcher can be used for extracting only incoming strings:</p>

<pre><code>val matcher: PartialFunction[Any, String] = {
  case s: String =&gt; s
}</code></pre>

<h3>Determining completion</h3>

<p>How can a response collector decide when it has collected enough responses? It depends on the use-case. Sometimes we're interested in collecting a certain set of responses, and sometimes we're only interested in a fixed number of responses. Let's create a trait for tracking responses:</p>

<pre><code>trait ResponseTracker[T] {
  def addResponse(response: T): ResponseTracker[T]
  def isDone: Boolean
}</code></pre>

<p>The trait <code>ResponseTracker</code> models the state of collected responses. The <code>addResponse</code> method is used for advancing the tracking, while <code>isDone</code> is used to detect when enough responses have been collected. Let's see this in action:</p>

<pre><code>object Countdown {
  def apply(expectedMessagesCount: Int): Countdown = new Countdown(expectedMessagesCount)
}

class Countdown(expectedMessagesCount: Int) extends ResponseTracker[Any] {
  require(expectedMessagesCount &gt;= 0)

  def isDone: Boolean = expectedMessagesCount == 0

  def addResponse(response: Any): Countdown =
    new Countdown((expectedMessagesCount - 1) max 0)
}</code></pre>

<p>Here the <code>Countdown</code> is used for tracking the number of responses that been received. The tracker is initialised with the number of expected messages. When the number of expected messages have been received, the tracker will report as being done. Tracking the number of responses could be used for getting a rough sample of responses. Here's another example:</p>

<pre><code>object MatchIds {
  def apply[Msg, Id](expectedIds: Set[Id], toId: Msg =&gt; Id): MatchIds[Msg, Id] =
    new MatchIds(expectedIds, toId)
}

class MatchIds[Msg, Id](expectedIds: Set[Id], toId: Msg =&gt; Id)
  extends ResponseTracker[Msg] {

  def isDone: Boolean = expectedIds.isEmpty

  def addResponse(response: Msg): MatchIds[Msg, Id] =
    new MatchIds(expectedIds - toId(response), toId)
}</code></pre>

<p>Here the <code>MatchIds</code> is used for tracking IDs in certain responses. The tracker is initialised with a set of expected IDs and a function for extracting an ID from an incoming response. When a response is received, the ID of the response is removed from the expected IDs. When there are no more expected IDs, the tracker will report as being done.</p>

<h3>Delivering results and timing out</h3>

<p>The collected results can be provided to actors using actor messaging, but another delivery mechanism is needed for code that doesn't read messages from an actor mailbox.</p>

<p>The collected results can be made available using <code>Future</code> values. A future value represents a placeholder for a value that is yet to be completed. In our case, the value is the sequence of all the collected results: <code>Future[Iterable[T]]</code> where <code>T</code> is the type of the expected results. Alternatively, if there's an error in the system, the future can be completed with an exception.</p>

<p>Sometimes everything doesn't go as planned, and some of the responses never arrive to the response collector. It's good to have a backup plan: stop waiting for responses after a certain amount time has passed. The timeout can be provided to the response collector using Scala's <code>FiniteDuration</code>.</p>

<p>It's also a good idea to convey the timeout event to the consumer of the results. This can be achieved by completing the results with a timeout error. However, it may be useful to be able to inspect what values were collected before the timeout was reached. Thus, it's a good idea to represent the partial results in the type level:</p>

<pre><code>sealed trait ResultState
case object Full extends ResultState
case object Partial extends ResultState

case class Result[T](values: Iterable[T], state: ResultState)</code></pre>

<p>The type <code>Result[T]</code> contains the collection of all the received responses and a value that tells whether all of the responses were received or not. The type parameter <code>T</code> is the type of the expected results.</p>

<h2>Response collector implementation</h2>

<p>Using the APIs described above, we can create an implementation of the response collector. We'll start by introducing a new actor, <code>ResponseCollector</code>:</p>

<pre><code>import akka.actor._
import scala.concurrent.duration._
import scala.concurrent.Promise

class ResponseCollector[T](
  timeout: FiniteDuration,
  initialTracker: ResponseTracker[T],
  result: Promise[Result[T]],
  matcher: PartialFunction[Any, T])
  extends Actor with ActorLogging {

  // ...
}</code></pre>

<p>The <code>ResponseCollector</code> has a type parameter <code>T</code> that represents the type of the collected responses. The actor is initialised with:</p>

<ul>
<li>a timeout duration after which the actor stops listening for responses.</li>
<li>an initial tracker that is used for detecting when collection is finished.</li>
<li>a value that can be fulfilled once (<code>Promise</code>) with the collected results. The <code>Promise</code> can be provided to the consumer as a <code>Future</code>.</li>
<li>a matcher that is used for selecting only the interesting responses from the incoming messages.</li>
</ul>

<p>Inside the class a timeout event is set to be triggered after the given timeout duration has passed. This is done by scheduling a message delivery to the same actor. The <code>ReceiveTimeout</code> message from package <code>akka.actor</code> is used as the timeout message.</p>

<pre><code>import context.dispatcher

private val scheduledTimeout = context.system.scheduler.scheduleOnce(
  timeout, self, ReceiveTimeout
)</code></pre>

<p>The actor has a custom message handler that has state. The state contains a collection of received responses, and the current state of the response tracker.</p>

<p>In this handler, only the messages matched by the <code>matcher</code> are selected. On match, the response is appended to the collection of already collected responses. The handler also advances the response tracker, and checks whether enough responses were collected. If the tracker reports as being done, the collected results are reported back to the consumer using the <code>Promise</code> passed in the actor constructor, and the actor stops itself. If there are still more responses to be collected, the actor replaces its message handler to include the updated responses and response tracker.</p>

<pre><code>private def ready(responses: Vector[T], tracker: ResponseTracker[T]): Receive = {
  case m if matcher.isDefinedAt(m) =&gt;
    val response = matcher(m)
    val nextResponses = responses :+ response
    val nextTracker = tracker.addResponse(response)

    if (nextTracker.isDone) {
      log.info(&quot;All responses received.&quot;)
      result.success(Result(nextResponses, Full))
      context.stop(self)
    } else {
      context.become(ready(nextResponses, nextTracker))
    }

  case ReceiveTimeout =&gt;
    log.warning(&quot;Response collection timed out&quot;)
    result.success(Result(responses, Partial))
    context.stop(self)

  case m =&gt;
    log.warning(&quot;Unknown message: {}&quot;, m)
}</code></pre>

<p>Besides handling the incoming responses, the handler also handles the timeout event. When the actor receives <code>ReceiveTimeout</code>, it will report the collected results back to the consumer as a partial result, and shutdown the actor.</p>

<p>Finally, the actor is set up with the custom message handler with an initial state as the actor's first message handler.</p>

<pre><code>def receive: Receive = ready(Vector.empty, initialTracker)</code></pre>

<p>In addition to the actor, we can also provide helpful functions for creating instances of the actor. The <code>props</code> function is used for creating the <code>Props</code> recipe for the actor. The <code>apply</code> function creates the response collector, and exposes only the collected results as a <code>Future</code> and the reference of the actor. In both cases, the timeout is passed as an implicit parameter in a similar style as it's passed when using the ask pattern. For <code>apply</code> we also pass an <code>ActorRefFactory</code> implicitly, which can be, for example, an actor system or the context of an actor.</p>

<pre><code>import akka.util.Timeout

object ResponseCollector {
  def props[T](
    tracker: ResponseTracker[T],
    result: Promise[Result[T]],
    matcher: PartialFunction[Any, T])
    (implicit timeout: Timeout): Props =
      Props(new ResponseCollector(timeout.duration, tracker, result, matcher))

  def apply[T](tracker: ResponseTracker[T], matcher: PartialFunction[Any, T])
              (implicit timeout: Timeout, factory: ActorRefFactory) = {
    val result = Promise[Result[T]]()
    val ref = factory.actorOf(props(tracker, result, matcher))
    (result.future, ref)
  }
}</code></pre>

<h2>Example</h2>

<p>Let's create a small example demonstrating the use of <code>ResponseCollector</code>. In this scenario, we have some data distributed among actors. To keep this example simple, our data set is represented by an in-memory hash map. Our <code>DataStore</code> actor serves data from a map to anyone who requests it by key:</p>

<pre><code>case class Data(id: String, contents: String) {
  override def toString: String = s&quot;[$id: $contents]&quot;
}

object DataStore {
  def props(id: String, items: Map[Int, String]) = Props(new DataStore(id, items))
}

class DataStore(id: String, items: Map[Int, String]) extends Actor {
  def receive: Receive = {
    case i: Int =&gt; items.get(i).foreach(v =&gt; sender() ! Data(id, v))
  }
}</code></pre>

<p>The <code>DataStore</code> also sends an ID specific to the store along with the data from the map. The ID can be used for identifying the source of the data. The <code>DataStore</code> will also ignore any requests where key is not found from the map.</p>

<p>For this example, we'll set up three different data stores. All of the stores contain some information for keys 1-3 except the last one.</p>

<pre><code>implicit val system = ActorSystem()

val allStores = List(
  system.actorOf(DataStore.props(
    &quot;name&quot;,
    Map(1 -&gt; &quot;Mike&quot;, 2 -&gt; &quot;Robert&quot;, 3 -&gt; &quot;Joe&quot;)
  )),
  system.actorOf(DataStore.props(
    &quot;location&quot;,
    Map(1 -&gt; &quot;UK&quot;, 2 -&gt; &quot;Sweden&quot;, 3 -&gt; &quot;Germany&quot;)
  )),
  system.actorOf(DataStore.props(
    &quot;lastPurchase&quot;,
    Map(1 -&gt; &quot;couch&quot;, 2 -&gt; &quot;laptop&quot;)
  ))
)</code></pre>

<p>For each key, we'll set up a response collector that collects data from each data store. The collectors are only interested in <code>Data</code> objects, so we'll adjust their matchers accordingly:</p>

<pre><code>val matcher: PartialFunction[Any, Data] = { case d: Data =&gt; d }</code></pre>

<p>In order to know when the collectors can stop collecting, we'll use <code>MatchIds</code> and the IDs from the incoming data to track which data stores have responded.</p>

<pre><code>def getId(e: Data): String = e.id
val tracker = MatchIds(Set(&quot;name&quot;, &quot;location&quot;, &quot;lastPurchase&quot;), getId)</code></pre>

<p>Using the matcher and the tracker we can now set up the response collectors. As a result, we receive a <code>Future</code> value for the collector results and an actor reference to the collector. We'll pass the timeout as an implicit parameter to the collectors.</p>

<pre><code>implicit val timeout = Timeout(1.second)
val (result1, collector1) = ResponseCollector(tracker, matcher)
val (result2, collector2) = ResponseCollector(tracker, matcher)
val (result3, collector3) = ResponseCollector(tracker, matcher)</code></pre>

<p>We can use the collector actor references as the sender when requesting data from the data stores, so that the responses will be sent to the collectors.</p>

<pre><code>allStores.foreach { store =&gt;
  store.tell(1, collector1)
  store.tell(2, collector2)
  store.tell(3, collector3)
}</code></pre>

<p>Finally, we'll serve the results to the user using the <code>Future</code> values we received earlier. For this example we'll just print the results:</p>

<pre><code>def printResult(r: Result[Data]): Unit = {
  val status = r.state match {
    case Full =&gt; &quot;All values received&quot;
    case Partial =&gt; &quot;Only some values received&quot;
  }
  val values = r.values.mkString(&quot;, &quot;)
  println(s&quot;$status: $values&quot;)
}

implicit val ec = system.dispatcher

result1.foreach(printResult)
result2.foreach(printResult)
result3.foreach(printResult)</code></pre>

<p>Running this example will print out the results for all three collectors. The first two results will print out the full results. Since we didn't specify the <code>lastPurchase</code> information for the third key, the third collector will timeout after one second, and only partial results will be printed out.</p>

<pre><code>All values received: [lastPurchase: laptop], [name: Robert], [location: Sweden]
All values received: [lastPurchase: couch], [name: Mike], [location: UK]
Only some values received: [name: Joe], [location: Germany]</code></pre>

<h2>Conclusions</h2>

<p>In this article, I've demonstrated how to implement a reusable response collector actor. The solution allows customisation of how the actor determines when it has received enough responses, how it determines which responses are relevant, and how long it will wait for responses before timing out and delivering partial results. I also showed an example of how to use the actor and how it behaves.</p>

<p>There's still room for customisation and improvements to the actor. For example, the timeout mechanism could be customised to reset after each collected response, error handling could be added, and the responses could be delivered as a stream instead of a batch.</p>

<p>I've made the code available in a <a href="https://gist.github.com/jkpl/0c1a70e642be0b2422e3">Github Gist</a>. Feel free to extend the code as you wish.</p>

<p>Thanks for reading, and happy hAkking!</p>
